/**
* prot
* No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
*
* The version of the OpenAPI document: 1.0
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "DefaultApiImpl.h"
#include "trace_bullet.hpp"
#include "form_runner.h"

namespace org {
namespace openapitools {
namespace server {
namespace api {

using namespace org::openapitools::server::model;

DefaultApiImpl::DefaultApiImpl(std::shared_ptr<Pistache::Rest::Router> rtr)
    : DefaultApi(rtr)
    { }

void DefaultApiImpl::delete_userusername(const std::string &username, Pistache::Http::ResponseWriter &response) {
    if(delete_user(username)){
        response.send(Pistache::Http::Code::Ok, "Done");
    }else{
        response.send(Pistache::Http::Code::Not_Found, "Username doest not exists");
    }
}

void DefaultApiImpl::apps_get(Pistache::Http::ResponseWriter &response) {
    auto binds_forms = read_form_names();
    vector<Prot_app_info> apps;
    for (auto &[ k,v] : binds_forms)
    {
        Prot_app_info app;
        app.setFormId(k);
        app.setFormName(v);
        apps.push_back(app);
    }
    json jresponse = apps;
    response.send(Pistache::Http::Code::Ok, jresponse.dump(4));
}

void DefaultApiImpl::apps_id_get(const int32_t &id, Pistache::Http::ResponseWriter &response){
    auto ff = read_form_by_id(id);
    if(!ff.has_value()){
        response.send(Pistache::Http::Code::Not_Found, "app id doesn't match any");
        return;
    }
    auto paired = ff.value();
    Prot_app_info app;
    app.setFormId(paired.first);
    app.setFormName(paired.second);
    json jresponse = app;
    response.send(Pistache::Http::Code::Ok, jresponse.dump(4));
}

void DefaultApiImpl::user_developer_form_get(const std::string &developer, Pistache::Http::ResponseWriter &response) {
    //Need to create a new call that joins forms, by a given developer
    auto mp = read_forms_by_developer(developer);
    vector<string> form_names;

    for_each(mp.begin(), mp.end(), [&form_names](const pair<uint64_t,string>& c){
        form_names.push_back(c.second);
    });
    json jresponse = form_names;
    response.send(Pistache::Http::Code::Ok, jresponse.dump(4) );
}
void DefaultApiImpl::user_developer_form_form_id_get(const std::string &developer, const int32_t &formId, Pistache::Http::ResponseWriter &response) {
    auto form_ =read_form_by_id (formId);
    if(!form_.has_value()){
        response.send(Pistache::Http::Code::Not_Found, "not form for that id");
        return;
    }
    auto form_res =read_form(form_.value().second);
    
    response.send(Pistache::Http::Code::Ok, form_res->get_json().dump(4));
}

void DefaultApiImpl::user_username_apps_get(const std::string &username, Pistache::Http::ResponseWriter &response) {
    if(!gen_exists<test_prot::Users>(username)){
        response.send(Pistache::Http::Code::Not_Found, "user does not exists");
        return;
    }
    json jsresponse;
    for(const auto & [k,v] : read_instalations(username) ){
        json inner;
        inner["appID"] = k;
        inner["appName"] = v;
        jsresponse.push_back(inner);
    }

    response.send(Pistache::Http::Code::Ok, jsresponse.dump(4));
}

void DefaultApiImpl::user_username_apps_install_app_id_get(const std::string &username, const int32_t &installAppId, Pistache::Http::ResponseWriter &response) {
    if(!gen_exists<test_prot::Users>(username)){
        response.send(Pistache::Http::Code::Not_Found, "user does not exists");
        return;
    }
    auto res = read_instalations(username, installAppId);
    if(res.empty()){
        response.send(Pistache::Http::Code::Not_Found, "Not found id");
        return;
    }
    json jsresponse;
    jsresponse["appID"]= res.begin()->first;
    jsresponse["appName"]= res.begin()->second;

    response.send(Pistache::Http::Code::Ok, jsresponse.dump(4));
}

void DefaultApiImpl::user_username_questionary_app_id_get(const std::string &username, const int32_t &appId, Pistache::Http::ResponseWriter &response) {
    //This is the request of questions
    auto usr = read_user(username);
    if(!usr){
        response.send(Pistache::Http::Code::Not_Found, "user does not exists");
        return;
    }

    auto pair = read_form_by_id(appId);
    auto form_ = read_form(pair->second);
    if(!form_){
        response.send(Pistache::Http::Code::Not_Found, "form does not exists");
        return ;
    }
    form_runner fr(*usr, *form_);
    json qa_request1;
    auto & qa_res = fr.run(qa_request1);
    Inline_response_200 response_200;
    response_200.setCurrentQuestion(qa_res["next_question"].get<string>());

    response.send(Pistache::Http::Code::Ok, json(response_200).dump(4));
}

void DefaultApiImpl::user_username_tasks_get(const std::string &username, Pistache::Http::ResponseWriter &response) {
    //Get all tasks for the user
    auto tsks = read_tasks(username);
    json jresponse;
    for (auto &&i : tsks)
    {
        jresponse.push_back(json(*i));
    }
    
    response.send(Pistache::Http::Code::Ok, jresponse.dump(4) );
}
void DefaultApiImpl::post_userdeveloper_form(const std::string &developer, const Inline_object_1 &inlineObject1, Pistache::Http::ResponseWriter &response) {
    if(!gen_exists<test_prot::Users>(developer)){
        response.send(Pistache::Http::Code::Unauthorized, "Developer does not exists as user");
    }
    auto res = create_form(json::parse( inlineObject1.getJsonStr() ),developer);
    if(!res){
        response.send(Pistache::Http::Code::Not_Acceptable, "bad json");

    }
    response.send(Pistache::Http::Code::Created, "Done");
}
void DefaultApiImpl::user_username_questionary_app_id_post(const std::string &username, const int32_t &appId, const Inline_object_2 &inlineObject2, Pistache::Http::ResponseWriter &response) {
    auto usr = read_user(username);
    if(!usr){
        response.send(Pistache::Http::Code::Not_Found, "user does not exists");
        return;
    }
    if(inlineObject2.restartIsSet()){
        response.send(Pistache::Http::Code::Ok, "Rested " + username + " " + std::to_string(appId) );

        return;
    }
    auto pair = read_form_by_id(appId);
    auto form_ = read_form(pair->second);
    form_runner fr(*usr, *form_);
    json qa_request;
    qa_request["answer"] = inlineObject2.getResponse();
    auto & qa_res = fr.run(qa_request);

    Inline_response_200 response_200;
    response_200.setCurrentQuestion(qa_res["next_question"].get<string>());
    response.send(Pistache::Http::Code::Ok, json(response_200).dump(4));
}

void DefaultApiImpl::user_post(const Inline_object &inlineObject, Pistache::Http::ResponseWriter &response) {
    auto usr = create_user(inlineObject.getUsername());
    if(!usr){
        response.send(Pistache::Http::Code::Bad_Request, "Already exists");
        return;
    }
    
    response.send(Pistache::Http::Code::Ok, "Created");
}

void DefaultApiImpl::user_username_get(const std::string &username, Pistache::Http::ResponseWriter &response) {

    const auto usr = read_user(username);
    if(!usr){
        response.send(Pistache::Http::Code::Not_Found, "username does not exists");
        return;
    }
    json js = *usr;
    response.send(Pistache::Http::Code::Ok, js.dump(4));
}

}
}
}
}

